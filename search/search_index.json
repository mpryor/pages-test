{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Knowledge This is my obsidian \"second brain\". A centralized place for notes on things I learn. The goal here is not encyclopedic coverage, but rather quality reminders, highlights, and references. Note: take everything with a grain of salt. This may be filled with mistakes, misunderstandings, lies, misinformation, and/or propaganda.","title":"Knowledge"},{"location":"#knowledge","text":"This is my obsidian \"second brain\". A centralized place for notes on things I learn. The goal here is not encyclopedic coverage, but rather quality reminders, highlights, and references. Note: take everything with a grain of salt. This may be filled with mistakes, misunderstandings, lies, misinformation, and/or propaganda.","title":"Knowledge"},{"location":"business/essentialism/","text":"Essentialism - Greg McKeown Trade offs are an inherent part of life, and not necessarily a negative part of life. This book explored how you can use trade offs to your advantage to protect your time and chose activities and habits purposefully to maximize your potential or your businesses potential. Essentialists take time to explore and evaluate a broad set of options before committing to any. Once you commit it's best to \"go big\", so it's best to spend time making sure an idea or activity is vital before taking it on. Explore options first and pick the right one later. Have extreme criteria for things you take on. Once you finish exploring your options, the answer can only be \"HELL YEA or no\". If you allow your selective criteria to degrade, anything becomes a target. If a business says yes to any project a customer asks them to do, the morale of the company will plummet because you will lose any greater sense of purpose and it will become impossible to distinguish yourself in the marketplace. Because of this, you should say yes to only the top 10% of opportunities at most. Your criteria when saying yes should be \"Is this exactly what I am looking for\". Use Zero-Based budgeting in life. Whenever you have the opportunity to reevaluate your commitments, throw everything off the table and start from zero. Evaluate every item and justify every item again from scratch. Focus on primary obstacles. If you need to cut costs, focus on the least efficient thing first, followed by the second least efficient thing. If you are struggling with writers block, hiring a researcher would be a waste of time - instead you should focus on getting words on the page.","title":"Essentialism - Greg McKeown"},{"location":"business/essentialism/#essentialism-greg-mckeown","text":"Trade offs are an inherent part of life, and not necessarily a negative part of life. This book explored how you can use trade offs to your advantage to protect your time and chose activities and habits purposefully to maximize your potential or your businesses potential. Essentialists take time to explore and evaluate a broad set of options before committing to any. Once you commit it's best to \"go big\", so it's best to spend time making sure an idea or activity is vital before taking it on. Explore options first and pick the right one later. Have extreme criteria for things you take on. Once you finish exploring your options, the answer can only be \"HELL YEA or no\". If you allow your selective criteria to degrade, anything becomes a target. If a business says yes to any project a customer asks them to do, the morale of the company will plummet because you will lose any greater sense of purpose and it will become impossible to distinguish yourself in the marketplace. Because of this, you should say yes to only the top 10% of opportunities at most. Your criteria when saying yes should be \"Is this exactly what I am looking for\". Use Zero-Based budgeting in life. Whenever you have the opportunity to reevaluate your commitments, throw everything off the table and start from zero. Evaluate every item and justify every item again from scratch. Focus on primary obstacles. If you need to cut costs, focus on the least efficient thing first, followed by the second least efficient thing. If you are struggling with writers block, hiring a researcher would be a waste of time - instead you should focus on getting words on the page.","title":"Essentialism - Greg McKeown"},{"location":"math/algebra/complex-fractions/","text":"Complex fractions are fractions with fractions as the devisor or divedend Just remember to multiply by the reciprocal of the devisor. (2/3)/(3/4) = (2/3) * (4/3) = 8/9","title":"Complex fractions"},{"location":"math/algebra/equations/","text":"Expressions: just statements abc + c^3 + ab solve for a=2,b=-1,c-3 Inverse operations: used to keep equations balanced x+3-3 = x || sqrtx^2 = x Equations: x-3 = 10 -> x-3+3 = 10+3 -> x+0 = 13 -> x = 13 Simplify or evaluate expressions Balance or solve equations Equations with parentheses: 12 - (2x+5) = -2 + (x-3) // remember understood 1 here in front of parentheses 12 - 2x - 5 = -2 + x - 3 7 - 2x = -5 + x 12 - 2x = x 12 = 3x x = 4 Words to keep in mind: (*) = sum, increases (-) = difference x = product / = quotient","title":"Equations"},{"location":"math/algebra/factoring/","text":"Factoring is the act of \"un- distributing \" EX: 6 = 3 * 2 (factored out a 3, 2 is left over) There are multiple factoring methods depending on what you are presented with. Your goal is either to simplify (EX (x-8)(x+2) ) or to solve for \"the roots\" (EX x = -6 || x = 1 ) Solve for the roots by using the \"zero theorem\" (set polynomial = 0 first) EX x^2 + 5x - 6 = 0 Greatest Common Factor All terms must share a common factor that you can remove 3x + 6xy - 15ax 3x(1+2y-5a) Quadradic polynomial un-FOILing x^2 - 6x - 16 // Find the factors of -16 that sum to -6 (x-8)(x+2) You can check your work by multiplying the polynomials The difference of two squares Need two squares that can snap together 49a^2 - 36x^6y^4 (7a + 6x^3y^2)(7a - 6x^3y^2) Again, you can check your work by multiplying Completing the square x^2 + 10x + 6 = 0 // before you start, make sure the highest term is `+1x^2` and set the equation to 0. x^2 +10x = -6 // take the coefficient of the second term, devide by 2, square the result (10/2)^2 = +25 // add the result to both sides x^2 + 10x + 25 = 19 // now you can factor (x + 5)(x + 5) = 19 (x + 5)^2 = 19 sqt((x + 5)^2) = +/- sqt(19) // Because you take the square root, your answer will be both + and - x + 5 = +/- sqt(19) x = 5 +/- sqt(19) Notes: When completing the square with complex roots, you may end up in a situation like +/- sqt(-59/36) . Take the square root of the top and bottom of the fraction and factor out the square root of -1. +/- sqt(-59/36) = +/- (sqt(-1) * sqt(59))/sqt(36) = +/- (i * sqt(59))/6 The quadratic formula The quadratic formula can be discovered by completing the square of ax^2 + bx + c = 0 Once you have the formula x = (-b +/- sqt(b^2 - 4ac))/2a you can just plug in the variables and solve... assuming a > 0 Other uses You can factor to find the common denominator of a \"rational expression\" ((x + 3)/(x^2 - x - 6)) - (3/(3 - x)) ((x+3) / ((x-3)(x+2))) + (3 / (x-3)) // notice the factoring out of -1 and multiplication of the whole fraction right side is multiplied by (x + 2) to get greatest common denominator Fractions are added = (4x + 9) / (x^2 - x - 6)","title":"Factoring"},{"location":"math/algebra/factoring/#other-uses","text":"You can factor to find the common denominator of a \"rational expression\" ((x + 3)/(x^2 - x - 6)) - (3/(3 - x)) ((x+3) / ((x-3)(x+2))) + (3 / (x-3)) // notice the factoring out of -1 and multiplication of the whole fraction right side is multiplied by (x + 2) to get greatest common denominator Fractions are added = (4x + 9) / (x^2 - x - 6)","title":"Other uses"},{"location":"math/algebra/functions/","text":"In a function, every input value of x outputs a single value for y Every function has a domain (all valid real number arguments (x values)) and a range (all valid real number outputs (or y value)) To find the domain test the function for x > 0, x === 0 and x < 0. Look out for sqt(), log(), and fractions over x To find the range, plug in values from the domain and look for patterns You can prove functions using the vertical line test on a graph (no given value of x should result in 2 values) Functions can be even, odd, or neither: Even: f(-x) = f(x) Odd: f(-x) = -(f(x)) Neither: Both of the obove conditions are false Operations You can do all the normal operations with functions f(x) = x^2 + 4 g(x) = x - 2 (f + g)(x) = (x^2 + 4) + (x - 2) fg(x) = (x^2 + 4)(x - 2) = x^3 -2x^2 + 4x - 8","title":"Functions"},{"location":"math/algebra/functions/#operations","text":"You can do all the normal operations with functions f(x) = x^2 + 4 g(x) = x - 2 (f + g)(x) = (x^2 + 4) + (x - 2) fg(x) = (x^2 + 4)(x - 2) = x^3 -2x^2 + 4x - 8","title":"Operations"},{"location":"math/algebra/imaginary-numbers/","text":"i = sqt(-1) and i^2 = -1 remember sqt(ab) = sqt(a) * sqt(b) a + bi is called a complex number Rationalize complex denominators Use the conjugate method 2 + 3i / 4 - 2i (2 + 3i)(4 + 2i)/(4 - 2i)(4 + 2i) ... // here you foil and combine like terms and simplify complex numbers as much as you can (1 + 8i)/10","title":"Imaginary numbers"},{"location":"math/algebra/imaginary-numbers/#rationalize-complex-denominators","text":"Use the conjugate method 2 + 3i / 4 - 2i (2 + 3i)(4 + 2i)/(4 - 2i)(4 + 2i) ... // here you foil and combine like terms and simplify complex numbers as much as you can (1 + 8i)/10","title":"Rationalize complex denominators"},{"location":"math/algebra/inequalities/","text":"Equations are equal, inequalities are unequal Trichotomy: Two numbers can only be related in three ways -> a < b, a = b, a > b If a !>= b, a must be < b Negative inequalities: Solve like an equation, but flip the > || < sign when multiplying or deviding by a negative number.","title":"Inequalities"},{"location":"math/algebra/like-terms/","text":"Addition/Subtraction: 2x+x-3x+5x = 5x Multiplication: Multiply the number add the exponent 4x^2 x 3x^5 = 12x^7 Devision: Divide the number subtract the exponent 4x^3/2x = (4/2)(x^3-1) = 2x^2 and a^2/a^3 = a^-1/1 = 1/a","title":"Like terms"},{"location":"math/algebra/operations/","text":"Associative property: (a+b)+c = a+(b+c) Commutative property: ab = ba Transitive property: if a=b and b=c then a=c Distributive property: (a-c)b = ab-ac This can also be used with binomial multiplication: (a-b)(c-d) = ab-ac-bc+bd PEMDAS All grouping symbols ([{||}]) Exponents Multiplication/Devision Addition/Subtraction Understood 1: x = 1x^1/1","title":"Operations"},{"location":"math/algebra/polynomials/","text":"The sum of multiple power terms, EX: (-3x^4 + x^2) leading term = -3x^4 so degree = 4 Addition/Subtraction (3x^2 + 6x - 8) + (-12x^2 + 1) // remove parens (here with understood 1 multiplied) 3x^2 + 6x - 8 - 12x^2 + 1 3x^2 - 12x^2 + 6x - 8 + 1 // group decending by degree -9x^2 + 6x - 7 Multiplication Use the distributive property then combine like terms In multivariable, remember the rules of like terms Devision Use the first term of the devisor to find a value that you multiply through the devisor to get the next step in long devision. In multivariable polynomials, make sure to fully solve for the first step before bringing down the next step. (x^3 + y^3) / (x + y) x^3 / x = x^2 <--- solution x^2 * (x + y) = (x^3 + x^2y) (x^3 + 0x^2y) - (x^3 + x^2y) = -x^2y -x^2y / x = -xy <--- solution -xy * (x + y) = -x^2y - xy^2 (-x^2y + 0xy^2) - (-x^2 - xy^2) = xy^2 xy^2 / x = y^2 <--- solution y^2 * (x + y) = xy^2 + y^3 xy^2 + y^3(from original problem) - (xy^2 + y^3) = 0 <--- remainder solution: x^2 - xy + y^2","title":"Polynomials"},{"location":"math/algebra/polynomials/#additionsubtraction","text":"(3x^2 + 6x - 8) + (-12x^2 + 1) // remove parens (here with understood 1 multiplied) 3x^2 + 6x - 8 - 12x^2 + 1 3x^2 - 12x^2 + 6x - 8 + 1 // group decending by degree -9x^2 + 6x - 7","title":"Addition/Subtraction"},{"location":"math/algebra/polynomials/#multiplication","text":"Use the distributive property then combine like terms In multivariable, remember the rules of like terms","title":"Multiplication"},{"location":"math/algebra/polynomials/#devision","text":"Use the first term of the devisor to find a value that you multiply through the devisor to get the next step in long devision. In multivariable polynomials, make sure to fully solve for the first step before bringing down the next step. (x^3 + y^3) / (x + y) x^3 / x = x^2 <--- solution x^2 * (x + y) = (x^3 + x^2y) (x^3 + 0x^2y) - (x^3 + x^2y) = -x^2y -x^2y / x = -xy <--- solution -xy * (x + y) = -x^2y - xy^2 (-x^2y + 0xy^2) - (-x^2 - xy^2) = xy^2 xy^2 / x = y^2 <--- solution y^2 * (x + y) = xy^2 + y^3 xy^2 + y^3(from original problem) - (xy^2 + y^3) = 0 <--- remainder solution: x^2 - xy + y^2","title":"Devision"},{"location":"math/algebra/radicals/","text":"Powers of negative bases -5^2 = -25, -(5)^2 = 25 Powers of fractions (a/b)^3 = a^3/b^3 (sqt2/4)^3 = 2*sqt(2)/64 = sqt2/32 Negative exponents a^-b = 1/a^b and 1/a^-b = a^b Fractional exponents x^4/3 = (3sqt(x^4)) Rationalizing denominattors rules sqt(a/b) = sqta/sqtb sqt(ab) = sqta * sqtb sqta * sqta = a example 1/sqt2 1/sqt2 * sqt2/sqt2 1sqt2/2 sqt2/2 Conjugate method If your denominator is an irrational polynomial , you can multiply the fraction by it's conjugate . 3/(5 - sqt3) = (3/(5-sqt3)) * ((5+sqt3)/(5+sqt3)) Distribute, and then simplify","title":"Radicals"},{"location":"math/algebra/ratio-proportions/","text":"You can solve ratio and proportion problems with cross multiplication a/b = c/d (a/b) * b * d = (c/d) * b * d a * d = c * b You can freely convert between fractions, decimals and percents 4% = 4/100 = 0.04 0.49 = 49% 1/4 = 0.25 = 25% \"Find 6% of 99\" = (6/100) * 99 = 5.94","title":"Ratio proportions"},{"location":"math/algebra/rational-functions/","text":"f(x) = (x^2 + 2x - 7)/(x - 2) You can simplify with long devision of polynomials You can also simplify with cancelation 4(a-3)/4 = (4/4)(a-3) = a-3 Addition and subtraction Same as normal fractions - find a common denominator and add or subtract the numerator Multiplication Factor out both sides and use cancelation to simplify the equation. If you cancel a factor in the denominator that limits the domain of one of the functions, you need to explicitly provide that limitation in your simplified form because it limits the domain of the product. (4x^2 - 1)/(x^2 - 4) * (x-2)/(2x-1) (2x+1)(2x-1)/(x+2)(x-2) * x-2/2x-1 // cancel out 2x-1 and x-2 2x + 1 / x + 2 with x != 1/2 or 2 Devision Factor out both sides List all restrictions. Keep in mind all areas of the equation that can not be 0 (anything)/(x!=0) / (x!=0)/(x!=0) Multiply against the reciprocal of the devisor Cancel common factors List the solution with it's restrictions","title":"Rational functions"},{"location":"math/algebra/rational-functions/#addition-and-subtraction","text":"Same as normal fractions - find a common denominator and add or subtract the numerator","title":"Addition and subtraction"},{"location":"math/algebra/rational-functions/#multiplication","text":"Factor out both sides and use cancelation to simplify the equation. If you cancel a factor in the denominator that limits the domain of one of the functions, you need to explicitly provide that limitation in your simplified form because it limits the domain of the product. (4x^2 - 1)/(x^2 - 4) * (x-2)/(2x-1) (2x+1)(2x-1)/(x+2)(x-2) * x-2/2x-1 // cancel out 2x-1 and x-2 2x + 1 / x + 2 with x != 1/2 or 2","title":"Multiplication"},{"location":"math/algebra/rational-functions/#devision","text":"Factor out both sides List all restrictions. Keep in mind all areas of the equation that can not be 0 (anything)/(x!=0) / (x!=0)/(x!=0) Multiply against the reciprocal of the devisor Cancel common factors List the solution with it's restrictions","title":"Devision"},{"location":"math/algebra/slope/","text":"Slope = the change in y / the change in x Slope is normally represented with m Lines can be expressed in equations with: Point slope form y - y1 = m(x - x1) Slope intercept form y = mx + b where b is the y cordinate where the y axis is crossed","title":"Slope"},{"location":"math/algebra/systems-of-two-equations/","text":"You can solve systems of two equations in three ways: Substitution Solve for either x or y in one equation, plug in your value to the other equation and solve for the other variable, plug in your solution to the first equation to find your unique answer (x,y) Elimination Get one term to cancel by adding the equations together, solve for the remaining variable, and plug your solution into the first equation to get (x, y) Graphing Graph the two equations and the answer is where the lines cross at point (x, y)","title":"Systems of two equations"},{"location":"math/proofs/fundamentals/","text":"Fundamentals Sets All of mathematics can be described with sets. A set is a collection of elements . Sets can be infinite or finite. Sets are equal if they contain the same elements - even if they are listed in a different order. A = {1,2,3} 2 \u2208 A (read as 2 is in A) Some sets are special and get reserved symbols: N = All natural numbers Z = All integers R = All real numbers \u2205 = The empty set Q = The rational numbers Q = { x: x = m/n, where m,n \u2208 Z and n \u2260 0 } Sets can have anything as elements (numbers, strings, other sets, functions), or nothing, which makes them equal to the empty set or \u2205. The cardinality of a set is marked with ||. |{1,8}| = 2 Set-builder notation is used to describe sets that are hard to write out in full. X = {expression:rule} Example: E={2n:n\u2208Z} Read: \"E is the set of all things of form 2n, such that n is an element of Z\" Translation: E is the set of all n in (all integers) where n is even","title":"Fundamentals"},{"location":"math/proofs/fundamentals/#fundamentals","text":"","title":"Fundamentals"},{"location":"math/proofs/fundamentals/#sets","text":"All of mathematics can be described with sets. A set is a collection of elements . Sets can be infinite or finite. Sets are equal if they contain the same elements - even if they are listed in a different order. A = {1,2,3} 2 \u2208 A (read as 2 is in A) Some sets are special and get reserved symbols: N = All natural numbers Z = All integers R = All real numbers \u2205 = The empty set Q = The rational numbers Q = { x: x = m/n, where m,n \u2208 Z and n \u2260 0 } Sets can have anything as elements (numbers, strings, other sets, functions), or nothing, which makes them equal to the empty set or \u2205. The cardinality of a set is marked with ||. |{1,8}| = 2 Set-builder notation is used to describe sets that are hard to write out in full. X = {expression:rule} Example: E={2n:n\u2208Z} Read: \"E is the set of all things of form 2n, such that n is an element of Z\" Translation: E is the set of all n in (all integers) where n is even","title":"Sets"},{"location":"other/books/readme/","text":"This directory is for books that don't really fit into a specific category.","title":"Readme"},{"location":"other/books/stolen-focus/","text":"Stolen Focus: Why you can't pay attention and how to think deeply again This was a really amazing book that covered a lot of struggles unique to our generations. The switch cost effect A study by professor Michael Posner at the University of Oregon found that if you are focusing on something and you get interrupted, on average it will take twenty-three minutes for you to get back to the same state of focus. A different study of office workers in the US found most of them never get an hour of uninterrupted work in a day. All evidence suggests that, if you spend your time frequently switching tasks, you will be slower, make more mistakes, be less creative, and remember less of what you do. BF Skinner and Pigeons BF Skinner found that you could basically use clever reinforcement to get pigeons to behave any way you like. Here, Johann Hari argues that silicon valley companies use similar techniques to coerce profitable behavior out of humans. This includes producing products that keep us from getting a full 8 hours of sleep - because if you are asleep there is no chance that you are spending money. Social media reinforces some sketchy ideas - example: What matters most is whether people immediately agree with and applaud your short, simple, speedy statements. Somebody is your friend if you regularly look at their edited highlight reels and they look at yours - this is what friendship means. Product design courses at Stanford and beyond teach techniques for getting users \"hooked\" on these products that they were fine without. This reminds me of a quote from Hbomberguy's video on woke brands -> \"We're gunna gitcha\" Mindfulness Many tech companies advocate for mindfulness in the workplace with yoga/meditation workshops while simultaneously producing products that perpetrate non-mindfulness in the world. Nutrition Eating crappy diets causes blood sugar inconsistency and poor gut biome development, both of which are proven to have major impacts on an individuals ability to focus. In the words of Dale Pinnock: Stop feeding them fucking Coke for breakfast and a bowl of sugar and milk Summary I thought the whole book was summed up pretty well by James Williams' (ex-google strategist) three layers of attention. Spotlight: \"Immediate actions\", like what you are currently doing. This is what get's disturbed by the switch-cost effect. Starlight: \"Long term projects over time\". This attention is what gets you through school or other long term goals. If you get distracted here, you will not accomplish your long term goals because you will not be able to prioritize. Daylight: \"Knowledge of why you have chosen any goals or immediate actions\". How do you know you want to write a book? How do you know you want to start a business? If you get distracted at this level you may not even be able to figure out who you are, what you want to do, or where you want to go.","title":"Stolen Focus: Why you can't pay attention and how to think deeply again"},{"location":"other/books/stolen-focus/#stolen-focus-why-you-cant-pay-attention-and-how-to-think-deeply-again","text":"This was a really amazing book that covered a lot of struggles unique to our generations.","title":"Stolen Focus: Why you can't pay attention and how to think deeply again"},{"location":"other/books/stolen-focus/#the-switch-cost-effect","text":"A study by professor Michael Posner at the University of Oregon found that if you are focusing on something and you get interrupted, on average it will take twenty-three minutes for you to get back to the same state of focus. A different study of office workers in the US found most of them never get an hour of uninterrupted work in a day. All evidence suggests that, if you spend your time frequently switching tasks, you will be slower, make more mistakes, be less creative, and remember less of what you do.","title":"The switch cost effect"},{"location":"other/books/stolen-focus/#bf-skinner-and-pigeons","text":"BF Skinner found that you could basically use clever reinforcement to get pigeons to behave any way you like. Here, Johann Hari argues that silicon valley companies use similar techniques to coerce profitable behavior out of humans. This includes producing products that keep us from getting a full 8 hours of sleep - because if you are asleep there is no chance that you are spending money. Social media reinforces some sketchy ideas - example: What matters most is whether people immediately agree with and applaud your short, simple, speedy statements. Somebody is your friend if you regularly look at their edited highlight reels and they look at yours - this is what friendship means. Product design courses at Stanford and beyond teach techniques for getting users \"hooked\" on these products that they were fine without. This reminds me of a quote from Hbomberguy's video on woke brands -> \"We're gunna gitcha\"","title":"BF Skinner and Pigeons"},{"location":"other/books/stolen-focus/#mindfulness","text":"Many tech companies advocate for mindfulness in the workplace with yoga/meditation workshops while simultaneously producing products that perpetrate non-mindfulness in the world.","title":"Mindfulness"},{"location":"other/books/stolen-focus/#nutrition","text":"Eating crappy diets causes blood sugar inconsistency and poor gut biome development, both of which are proven to have major impacts on an individuals ability to focus. In the words of Dale Pinnock: Stop feeding them fucking Coke for breakfast and a bowl of sugar and milk","title":"Nutrition"},{"location":"other/books/stolen-focus/#summary","text":"I thought the whole book was summed up pretty well by James Williams' (ex-google strategist) three layers of attention. Spotlight: \"Immediate actions\", like what you are currently doing. This is what get's disturbed by the switch-cost effect. Starlight: \"Long term projects over time\". This attention is what gets you through school or other long term goals. If you get distracted here, you will not accomplish your long term goals because you will not be able to prioritize. Daylight: \"Knowledge of why you have chosen any goals or immediate actions\". How do you know you want to write a book? How do you know you want to start a business? If you get distracted at this level you may not even be able to figure out who you are, what you want to do, or where you want to go.","title":"Summary"},{"location":"other/religion/yoga/","text":"The restraint of the modifications of the mind-stuff is Yoga.","title":"Yoga"},{"location":"other/veganism/animal-liberation/","text":"Animal Liberation By: Peter Singer Ethics Peter defends veganism philosophically by extending the \"principle of equality\" across all living things with a nervous system(ish). There is no valuable line you can draw where creatures above that line deserve not to be farmed and creatures below that line do. Experiments Peter says we should only use animals for painful experiments when the situation is so dire that we also would use mentally undeveloped baby humans. Veggie diet The science is extremely clear that humans can live long and healthy live off of nothing but plants. Therefore, eating animals or there secretions is a choice - not a need (for most humans in developed nations). When given the choice, we are ethically required to be consistent and extend the principle of equality to animals so that we are not speciesist and cause suffering for no reason. The only exceptions Peter sees could be totally free range eggs and muscles.","title":"Animal Liberation"},{"location":"other/veganism/animal-liberation/#animal-liberation","text":"By: Peter Singer","title":"Animal Liberation"},{"location":"other/veganism/animal-liberation/#ethics","text":"Peter defends veganism philosophically by extending the \"principle of equality\" across all living things with a nervous system(ish). There is no valuable line you can draw where creatures above that line deserve not to be farmed and creatures below that line do.","title":"Ethics"},{"location":"other/veganism/animal-liberation/#experiments","text":"Peter says we should only use animals for painful experiments when the situation is so dire that we also would use mentally undeveloped baby humans.","title":"Experiments"},{"location":"other/veganism/animal-liberation/#veggie-diet","text":"The science is extremely clear that humans can live long and healthy live off of nothing but plants. Therefore, eating animals or there secretions is a choice - not a need (for most humans in developed nations). When given the choice, we are ethically required to be consistent and extend the principle of equality to animals so that we are not speciesist and cause suffering for no reason. The only exceptions Peter sees could be totally free range eggs and muscles.","title":"Veggie diet"},{"location":"other/veganism/general/","text":"Veganism Single biggest way to reduce environmental impact on earth - Oxford/Science: https://science.sciencemag.org/content/360/6392/987 Veganism is suitable for all stages of life - American Academy of Nutrition and Dietetics: https://pubmed.ncbi.nlm.nih.gov/27886704/","title":"Veganism"},{"location":"other/veganism/general/#veganism","text":"Single biggest way to reduce environmental impact on earth - Oxford/Science: https://science.sciencemag.org/content/360/6392/987 Veganism is suitable for all stages of life - American Academy of Nutrition and Dietetics: https://pubmed.ncbi.nlm.nih.gov/27886704/","title":"Veganism"},{"location":"philosophy/1984/","text":"1984 By George Orwell Winston lives in Oceania and is self aware although the thought police are everywhere and big brother is watching and stuff. He falls in love with Julia who does not hate the government in the same way he does but also it does not really matter so they hang out and stuff. One day the thought police show they have known all about everything the whole time and then they torture Winston until he succumbs to doublethink and learns to love big brother. I found this book to be less solid then Brave New World or the Handmaids Tale. I loved the idea of whoever owns the past owns reality - but I don't see it as being possible to the extent that the book displays. I like the twist where the thought police were actually way more advanced then they seemed the whole book.","title":"1984"},{"location":"philosophy/1984/#1984","text":"By George Orwell Winston lives in Oceania and is self aware although the thought police are everywhere and big brother is watching and stuff. He falls in love with Julia who does not hate the government in the same way he does but also it does not really matter so they hang out and stuff. One day the thought police show they have known all about everything the whole time and then they torture Winston until he succumbs to doublethink and learns to love big brother. I found this book to be less solid then Brave New World or the Handmaids Tale. I loved the idea of whoever owns the past owns reality - but I don't see it as being possible to the extent that the book displays. I like the twist where the thought police were actually way more advanced then they seemed the whole book.","title":"1984"},{"location":"philosophy/better-never-to-have-been/","text":"Better Never To Have Been By David Benatar In this book David argues that coming into existence is always a serious harm to the person existing. He argues this is the case regardless of how much pleasure they experience in life or how much pleasure they bring to other people. The primary claim is an asymmetry of pleasure and pain . The presence of pain is bad The presence of pleasure is good The absence of pain is good, even if that good is not enjoyed by anyone (we are technically happy to know that there are not millions of people suffering on Mars right now) The absence of pleasure is not bad unless there is somebody for whom this absence is a deprivation (we do not morn that there are not millions of people enjoying life on Mars right now) There are also many other smaller claims: One can never have a child for that child's sake It is inconsistent to argue for the right to create a person and argue against the right for someone else to have a friend or family member immigrate Increasing one's value by having children is like increasing one's value by taking hostages etc... David also examines what it means to have \"a life worth living\" and \"a life worth continuing\".","title":"Better Never To Have Been"},{"location":"philosophy/better-never-to-have-been/#better-never-to-have-been","text":"By David Benatar In this book David argues that coming into existence is always a serious harm to the person existing. He argues this is the case regardless of how much pleasure they experience in life or how much pleasure they bring to other people. The primary claim is an asymmetry of pleasure and pain . The presence of pain is bad The presence of pleasure is good The absence of pain is good, even if that good is not enjoyed by anyone (we are technically happy to know that there are not millions of people suffering on Mars right now) The absence of pleasure is not bad unless there is somebody for whom this absence is a deprivation (we do not morn that there are not millions of people enjoying life on Mars right now) There are also many other smaller claims: One can never have a child for that child's sake It is inconsistent to argue for the right to create a person and argue against the right for someone else to have a friend or family member immigrate Increasing one's value by having children is like increasing one's value by taking hostages etc... David also examines what it means to have \"a life worth living\" and \"a life worth continuing\".","title":"Better Never To Have Been"},{"location":"programming/Golang/","text":"Go In Go, a name is exported if it begins with a capital letter. For example, Pizza is an exported name, as is Pi, which is exported from the math package. pizza and pi do not start with a capital letter, so they are not exported. Inside a function, the := short assignment statement can be used in place of a var declaration with implicit type. Outside a function, every statement begins with a keyword (var, func, and so on) and so the := construct is not available. Go's basic types are bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 The example shows variables of several types, and also that variable declarations may be \"factored\" into blocks, as with import statements. The int, uint, and uintptr types are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems. When you need an integer value you should use int unless you have a specific reason to use a sized or unsigned integer type. func main() { sum := 1 for ; sum < 1000; { // cool unique for loop sum += sum } fmt.Println(sum) } A defer statement defers the execution of a function until the surrounding function returns. The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns. package main import \"fmt\" func main() { defer fmt.Println(\"world\") fmt.Println(\"hello\") } Go has pointers. A pointer holds the memory address of a value. The type *T is a pointer to a T value. Its zero value is nil. var p *int The & operator generates a pointer to its operand. i := 42 p = &i The * operator denotes the pointer's underlying value. fmt.Println(*p) // read i through the pointer p p = 21 // set i through the pointer p This is known as \"dereferencing\" or \"indirecting\". Unlike C, Go has no pointer arithmetic. type Vertex struct { X int Y int } func main() { v := Vertex{1, 2} v.X = 4 fmt.Println(v.X) } type Vertex struct { X, Y int } var ( v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 p = &Vertex{1, 2} // has type *Vertex ) func main() { fmt.Println(v1, p, v2, v3) } func main() { a := make([]int, 5) printSlice(\"a\", a) b := make([]int, 0, 5) printSlice(\"b\", b) c := b[:2] printSlice(\"c\", c) d := c[2:5] printSlice(\"d\", d) } func printSlice(s string, x []int) { fmt.Printf(\"%s len=%d cap=%d %v\\n\", s, len(x), cap(x), x) } var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} func main() { for i, v := range pow { fmt.Printf(\"2**%d = %d\\n\", i, v) } } A field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored. struct { x, y float64 \"\" // an empty tag string is like an absent tag name string \"any string is permitted as a tag\" _ [4]byte \"ceci n'est pas un champ de structure\" } // A struct corresponding to a TimeStamp protocol buffer. // The tag strings define the protocol buffer field numbers; // they follow the convention outlined by the reflect package. struct { microsec uint64 `protobuf:\"1\"` serverIP6 uint64 `protobuf:\"2\"` } A map maps keys to values. The zero value of a map is nil. A nil map has no keys, nor can keys be added. The make function returns a map of the given type, initialized and ready for use. var m = map[string]Vertex{ \"Bell Labs\": {40.68433, -74.39967}, \"Google\": {37.42202, -122.08408}, } Go does not have classes. However, you can define methods on types. A method is a function with a special receiver argument. The receiver appears in its own argument list between the func keyword and the method name. In this example, the Abs method has a receiver of type Vertex named v. type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f < 0 { return float64(-f) } return float64(f) } func main() { f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) } The io package specifies the io.Reader interface, which represents the read end of a stream of data. The Go standard library contains many implementations of these interfaces, including files, network connections, compressors, ciphers, and others. The io.Reader interface has a Read method: func (T) Read(b []byte) (n int, err error) Read populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an io.EOF error when the stream ends. The example code creates a strings.Reader and consumes its output 8 bytes at a time. A goroutine is a lightweight thread managed by the Go runtime. go f(x, y, z) starts a new goroutine running f(x, y, z) The evaluation of f, x, y, and z happens in the current goroutine and the execution of f happens in the new goroutine. Goroutines run in the same address space, so access to shared memory must be synchronized. The sync package provides useful primitives, although you won't need them much in Go as there are other primitives. (See the next slide.) Channels are a typed conduit through which you can send and receive values with the channel operator, <-. ch <- v // Send v to channel ch. v := <-ch // Receive from ch, and // assign value to v. (The data flows in the direction of the arrow.) Like maps and slices, channels must be created before use: ch := make(chan int) By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables. The example code sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines have completed their computation, it calculates the final result. package main import \"fmt\" func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c <- sum // send sum to c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := <-c, <-c // receive from c fmt.Println(x, y, x+y) }","title":"Go"},{"location":"programming/Golang/#go","text":"In Go, a name is exported if it begins with a capital letter. For example, Pizza is an exported name, as is Pi, which is exported from the math package. pizza and pi do not start with a capital letter, so they are not exported. Inside a function, the := short assignment statement can be used in place of a var declaration with implicit type. Outside a function, every statement begins with a keyword (var, func, and so on) and so the := construct is not available. Go's basic types are bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 The example shows variables of several types, and also that variable declarations may be \"factored\" into blocks, as with import statements. The int, uint, and uintptr types are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems. When you need an integer value you should use int unless you have a specific reason to use a sized or unsigned integer type. func main() { sum := 1 for ; sum < 1000; { // cool unique for loop sum += sum } fmt.Println(sum) } A defer statement defers the execution of a function until the surrounding function returns. The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns. package main import \"fmt\" func main() { defer fmt.Println(\"world\") fmt.Println(\"hello\") } Go has pointers. A pointer holds the memory address of a value. The type *T is a pointer to a T value. Its zero value is nil. var p *int The & operator generates a pointer to its operand. i := 42 p = &i The * operator denotes the pointer's underlying value. fmt.Println(*p) // read i through the pointer p p = 21 // set i through the pointer p This is known as \"dereferencing\" or \"indirecting\". Unlike C, Go has no pointer arithmetic. type Vertex struct { X int Y int } func main() { v := Vertex{1, 2} v.X = 4 fmt.Println(v.X) } type Vertex struct { X, Y int } var ( v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 p = &Vertex{1, 2} // has type *Vertex ) func main() { fmt.Println(v1, p, v2, v3) } func main() { a := make([]int, 5) printSlice(\"a\", a) b := make([]int, 0, 5) printSlice(\"b\", b) c := b[:2] printSlice(\"c\", c) d := c[2:5] printSlice(\"d\", d) } func printSlice(s string, x []int) { fmt.Printf(\"%s len=%d cap=%d %v\\n\", s, len(x), cap(x), x) } var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} func main() { for i, v := range pow { fmt.Printf(\"2**%d = %d\\n\", i, v) } } A field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored. struct { x, y float64 \"\" // an empty tag string is like an absent tag name string \"any string is permitted as a tag\" _ [4]byte \"ceci n'est pas un champ de structure\" } // A struct corresponding to a TimeStamp protocol buffer. // The tag strings define the protocol buffer field numbers; // they follow the convention outlined by the reflect package. struct { microsec uint64 `protobuf:\"1\"` serverIP6 uint64 `protobuf:\"2\"` } A map maps keys to values. The zero value of a map is nil. A nil map has no keys, nor can keys be added. The make function returns a map of the given type, initialized and ready for use. var m = map[string]Vertex{ \"Bell Labs\": {40.68433, -74.39967}, \"Google\": {37.42202, -122.08408}, } Go does not have classes. However, you can define methods on types. A method is a function with a special receiver argument. The receiver appears in its own argument list between the func keyword and the method name. In this example, the Abs method has a receiver of type Vertex named v. type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f < 0 { return float64(-f) } return float64(f) } func main() { f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) } The io package specifies the io.Reader interface, which represents the read end of a stream of data. The Go standard library contains many implementations of these interfaces, including files, network connections, compressors, ciphers, and others. The io.Reader interface has a Read method: func (T) Read(b []byte) (n int, err error) Read populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an io.EOF error when the stream ends. The example code creates a strings.Reader and consumes its output 8 bytes at a time. A goroutine is a lightweight thread managed by the Go runtime. go f(x, y, z) starts a new goroutine running f(x, y, z) The evaluation of f, x, y, and z happens in the current goroutine and the execution of f happens in the new goroutine. Goroutines run in the same address space, so access to shared memory must be synchronized. The sync package provides useful primitives, although you won't need them much in Go as there are other primitives. (See the next slide.) Channels are a typed conduit through which you can send and receive values with the channel operator, <-. ch <- v // Send v to channel ch. v := <-ch // Receive from ch, and // assign value to v. (The data flows in the direction of the arrow.) Like maps and slices, channels must be created before use: ch := make(chan int) By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables. The example code sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines have completed their computation, it calculates the final result. package main import \"fmt\" func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c <- sum // send sum to c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := <-c, <-c // receive from c fmt.Println(x, y, x+y) }","title":"Go"},{"location":"programming/clean-architecture/","text":"Clean Architecture By Robert C. Martin Behavior vs Architecture Getting code to work, once, is not very hard and can be accomplished with sheer brute force of will. The goal of design and architecture is to reduce the amount of resources it takes to produce and maintain a system. When a project starts, the complexity of each feature is equal to the complexity of the feature itself - but if architecture is not managed, the complexity of each feature becomes higher by some degree until the project grinds to a halt. Both behavior and architecture are equally important in a system. If you only work on behavior, the project will become ever more costly to develop, and eventually impossible to change. Behavior is not discussed in this book. This book covers the entire other half, architecture . TLDR: Paradigmes restrict engineers from making mistakes and enable them to write scientifically falsifiable code (or mathmatically provable code in some circumstances). You use paradigmes to code up modules . Modules are a group of behaviors that are responsible to one actor. You combine modules to create components . Components are independent .jar files, ruby gems etc. They can also be deployed as services. They balance many concerns to be easy to change and easy to use. Abstract components should be stable and depend on few things, concrete components should be flexible and depend on many abstract things. Multiple components are strung together to create a product or project . Architecture is the strategy you use to keep a project open to development, deployment, operation, and maintenance. This is done best by keeping buisness rules (things your company would do manually if computers did not exist) abstract and knowing nothing about the concrete plug-ins of implementation (ui, frameworks, database, cloud providers, the web at all, etc...). You should write buisness rules to connect with implementation via simple objects and interfaces that the implementation layer can plug in to. You should delay the decision of implementation details as long as possible. Every layer of your project should be testable horizontally and testable vertically. Programming Paradigms There are three paradigms, and it is not likely that there will be any others. Each paradigme removes capabilities from the last, and there is not anything left that the author sees could be removed. Structured Programming Imposes discipline on direct transfer of control Edsger Dijkstra used mathmatical proofs to prove programmatic structures and then tie them together to produce proven systems. He discovered that some uses of goto made proofs impossible to write. (Ones that prevented recursive decomposition) Nowdays most modern languages enforce structured programming which limits all programming to sequence, selection, and iteration . Dijkstra also said \"Testing shows the presence, not the absence, of bugs\". Programming shifted from trying to mathmatically prove programs as correct (because it litterally takes forever), to scientifically prove programs as correct enough for our purposes by using tests to find bugs. Object-Oriented Programming Imposes discipline on indirect transfer of control OOP did not give us encapsulation,inheritance or polymorphism. All three of those things are equally possible in a structured language like C. OOP did make polymorphism easy and safe by standerdizing the conventions for using pointers to functions and abstracting it away. In this way, OOP imposed discipline on indirect transfer of control - something that was possible but was also messy and unsafe in C. This discipline makes it practical to use dependancy inversion across projects. For a given caller class and callee , the caller can now reference an interface that represents any various implementation of the callee rather than refrencing the callee itself. This inverts the relationship between flow of control and source code dependencies. The big win from this revolution is that fact that you can point all external concerns (UI, Database, Etc...) to depend on the buisness rules - rahter than the other way around. So buisness rules can stay stable while details of implementation can change freely (ex: a fax program can work with any fax machine, not just be written for one piece of hardware). Changes to the UI or Database can have zero effect on buisness rules - which is super powerfull. Functional Programming Imposes discipline upon assignment Functional programming is based on lambda-calculus invented by Alonzo Church in the 1930s. All (or most) assignment is immutable. This is powerfull for architecture because it eleminates all problems that come from multiple threads and processors (race conditions, deadlock condition, concurrent update problems). Because machines are not infinitely powerful, you have to use this with care. In one case, event sourcing , applications limit operations on disk to Create and Read so that the data is immutable, but if you want to keep track of change over time you would need to recalculate that change from the beginning of time every time you read it, so you may make a compromise by caching some mutable state that can only be touched by a single \"mutable component\". SOLID Design Principles Solid principles can be applied at any level of the fractal of software design, but they must be applied at the module level. Modules make up components and components could be an independent .jar file, npm module, ruby gem, or service. SRP Single Responsibility Principle OCP Open-Closed Principle LSP Liskov Substitution Principle ISP Interface Segregation Principle DIP Dependency Inversion Principle Single Responsibility Principle A module should be responsible to one actor (aka code that changes together should live together). If the CEO and CTO both care about the budget system and make changes at different rates, there should be a module for both rather than one single budget module. Rather, you would have a single budget component . (Ex: Report Expenses Module and Group Expenses Module or whatever) Open-Closed Principle A module should be open for extension but closed for modification It is easier to write new code than it is to change old code. If component A should be protected from changes in component B, then component B should depend on component A. Abstract and stable code should have lots of dependants and few dependencies. Liskov Substitution Principle A simple violation of substitutability can cause a system's architecture to be polluted with a significant amount of extra mechanisms If something is similar to another thing they should be able to \"plug-in\" to the same interface without custom changes. Interface Segregation Principle Depending on something that carries baggage that you don't need can cause you troubles that you didn't expect Instead of depending on something that does a million things, depend on a interface you write that does exactly what you need - and then \"plug-in\" the thing that does a million things. Then you are only coupled to the functionality that you care about. Dependency Inversion Principle The most flexible systems depend on abstractions, not concretions Concrete implementation details should always depend on abstract stable code. Basically, buiseness logic should never need to change when the UI changes. Buiseness rules should never need to change when the database or ORM change. If you find yourself in a situation where the abstract is depending the concrete, you should invert the dependency by creating an interface and then the abstract code and concrete implementation both depend on the interface (which is abstract). Component Principles Gather together logic that changes together, dont depend on things you don't need, and version control your components. Components exist in a tension between three principals: CRP(avoid unneeded releases) | | |Too many changes |Hard to reuse | | | Your component | | | | | | | REP(reusers)--------------CCP(maintenance) | Too many releases REP - Reuse/Release Equivalence Principle: A component should be releasable together CCP - Common Closure Principle: A component should change together for only one reason CRP - Common Reuse Principle: Code that is reused together should be in the same component. If you depend on part of a component, you depend on the whole thing - so only depend on stuff you use 100% of. Component Coupling Always draw out your components and the dependencies between them, if there is a cycle use DIP to break the cycle so that you can work on components independently and not force extra releases. Component architecture should be flexible and allowed to change constantly. Stable Abstractions Principle A component should be as abstract as it is stable Components are sespended between the three principles outlined above while also being suspended between The zone of uselessness and The zone of pain . A component is in The zone of uselessness if it is abstract and nothing depends on it. (Ex: leftover dead abstract classes) A component is the The zone of pain if it is concrete and many things depend on it. (Ex: Database schema) You should aim to keep components as abstract as they are stable. So something that is depended on greatly should be greatly abstract, while something depended on by nothing can be extreamly concrete and depend on many things itself. Architecture It's all coming together... Basically a project can be split vertically and horizontally: Components (x), Use Cases (y) y (use cases EX: add order, delete order) | | | | | | | |------------- | | | |------------- | | ----------------- x (components EX: The ui, application-specific business rules, application-indebendent business rules, the database) You should be able to add use cases and components without interfearing with old ones. You should be able to pinpoint the exact code that handles a specific use case at a specific layer. This can all be in a monolith or components can be deployed as services - it does not really matter and is more domain specific. Consider the \"chattyness\" between layers. Remember that network requests are slow af, so if two layers are super chatty - having that chatter happen over the network will be slow. You should be able to test these layers horizontally (unit) and vertically (integration). Huzzah! Screaming Architecture When you look at an apps source code it should scream what it is. Ex: \"I AM A LOAN RISK ANALYSIS FINANCE APP CURRENTLY USING NEXTJS TO BE PRESENTED ON THE WEB\". rather than: \"I AM A CREATE-NEXT-APP.\" Clean Architecture Using all of the principles we have talked about, a clean architecture should be obvious by now | Abstract + Stable Entities (Enterprise Business Rules) *knows nothing about* Use Cases (Application Business Rules) *knows nothing about* Controllers + Presenters + Gateways (Interface Adapters) *knows nothing about* UI + Web + Devices + DB + External Interfaces (Frameworks & Drivers) | Concrete + Easy to change Yes, frameworks and databases and the web itself are all at the bottom. And, as a fractal, you can see this same architecture scaling up and down with each layer while maintaining the clarity of Use Cases vs Components and testing vertically/horizontally. Communication between these layers should be humble objects so that each layer is interchangable. You should be able to totally change frameworks at any time and only touch the bottom layer. Note: The start script (main) should be and interchangible plugin. You should easily be able to start in production, start in dev, start in qa, etc...","title":"Clean Architecture"},{"location":"programming/clean-architecture/#clean-architecture","text":"By Robert C. Martin","title":"Clean Architecture"},{"location":"programming/clean-architecture/#behavior-vs-architecture","text":"Getting code to work, once, is not very hard and can be accomplished with sheer brute force of will. The goal of design and architecture is to reduce the amount of resources it takes to produce and maintain a system. When a project starts, the complexity of each feature is equal to the complexity of the feature itself - but if architecture is not managed, the complexity of each feature becomes higher by some degree until the project grinds to a halt. Both behavior and architecture are equally important in a system. If you only work on behavior, the project will become ever more costly to develop, and eventually impossible to change. Behavior is not discussed in this book. This book covers the entire other half, architecture .","title":"Behavior vs Architecture"},{"location":"programming/clean-architecture/#tldr","text":"Paradigmes restrict engineers from making mistakes and enable them to write scientifically falsifiable code (or mathmatically provable code in some circumstances). You use paradigmes to code up modules . Modules are a group of behaviors that are responsible to one actor. You combine modules to create components . Components are independent .jar files, ruby gems etc. They can also be deployed as services. They balance many concerns to be easy to change and easy to use. Abstract components should be stable and depend on few things, concrete components should be flexible and depend on many abstract things. Multiple components are strung together to create a product or project . Architecture is the strategy you use to keep a project open to development, deployment, operation, and maintenance. This is done best by keeping buisness rules (things your company would do manually if computers did not exist) abstract and knowing nothing about the concrete plug-ins of implementation (ui, frameworks, database, cloud providers, the web at all, etc...). You should write buisness rules to connect with implementation via simple objects and interfaces that the implementation layer can plug in to. You should delay the decision of implementation details as long as possible. Every layer of your project should be testable horizontally and testable vertically.","title":"TLDR:"},{"location":"programming/clean-architecture/#programming-paradigms","text":"There are three paradigms, and it is not likely that there will be any others. Each paradigme removes capabilities from the last, and there is not anything left that the author sees could be removed.","title":"Programming Paradigms"},{"location":"programming/clean-architecture/#structured-programming","text":"Imposes discipline on direct transfer of control Edsger Dijkstra used mathmatical proofs to prove programmatic structures and then tie them together to produce proven systems. He discovered that some uses of goto made proofs impossible to write. (Ones that prevented recursive decomposition) Nowdays most modern languages enforce structured programming which limits all programming to sequence, selection, and iteration . Dijkstra also said \"Testing shows the presence, not the absence, of bugs\". Programming shifted from trying to mathmatically prove programs as correct (because it litterally takes forever), to scientifically prove programs as correct enough for our purposes by using tests to find bugs.","title":"Structured Programming"},{"location":"programming/clean-architecture/#object-oriented-programming","text":"Imposes discipline on indirect transfer of control OOP did not give us encapsulation,inheritance or polymorphism. All three of those things are equally possible in a structured language like C. OOP did make polymorphism easy and safe by standerdizing the conventions for using pointers to functions and abstracting it away. In this way, OOP imposed discipline on indirect transfer of control - something that was possible but was also messy and unsafe in C. This discipline makes it practical to use dependancy inversion across projects. For a given caller class and callee , the caller can now reference an interface that represents any various implementation of the callee rather than refrencing the callee itself. This inverts the relationship between flow of control and source code dependencies. The big win from this revolution is that fact that you can point all external concerns (UI, Database, Etc...) to depend on the buisness rules - rahter than the other way around. So buisness rules can stay stable while details of implementation can change freely (ex: a fax program can work with any fax machine, not just be written for one piece of hardware). Changes to the UI or Database can have zero effect on buisness rules - which is super powerfull.","title":"Object-Oriented Programming"},{"location":"programming/clean-architecture/#functional-programming","text":"Imposes discipline upon assignment Functional programming is based on lambda-calculus invented by Alonzo Church in the 1930s. All (or most) assignment is immutable. This is powerfull for architecture because it eleminates all problems that come from multiple threads and processors (race conditions, deadlock condition, concurrent update problems). Because machines are not infinitely powerful, you have to use this with care. In one case, event sourcing , applications limit operations on disk to Create and Read so that the data is immutable, but if you want to keep track of change over time you would need to recalculate that change from the beginning of time every time you read it, so you may make a compromise by caching some mutable state that can only be touched by a single \"mutable component\".","title":"Functional Programming"},{"location":"programming/clean-architecture/#solid-design-principles","text":"Solid principles can be applied at any level of the fractal of software design, but they must be applied at the module level. Modules make up components and components could be an independent .jar file, npm module, ruby gem, or service. SRP Single Responsibility Principle OCP Open-Closed Principle LSP Liskov Substitution Principle ISP Interface Segregation Principle DIP Dependency Inversion Principle","title":"SOLID Design Principles"},{"location":"programming/clean-architecture/#single-responsibility-principle","text":"A module should be responsible to one actor (aka code that changes together should live together). If the CEO and CTO both care about the budget system and make changes at different rates, there should be a module for both rather than one single budget module. Rather, you would have a single budget component . (Ex: Report Expenses Module and Group Expenses Module or whatever)","title":"Single Responsibility Principle"},{"location":"programming/clean-architecture/#open-closed-principle","text":"A module should be open for extension but closed for modification It is easier to write new code than it is to change old code. If component A should be protected from changes in component B, then component B should depend on component A. Abstract and stable code should have lots of dependants and few dependencies.","title":"Open-Closed Principle"},{"location":"programming/clean-architecture/#liskov-substitution-principle","text":"A simple violation of substitutability can cause a system's architecture to be polluted with a significant amount of extra mechanisms If something is similar to another thing they should be able to \"plug-in\" to the same interface without custom changes.","title":"Liskov Substitution Principle"},{"location":"programming/clean-architecture/#interface-segregation-principle","text":"Depending on something that carries baggage that you don't need can cause you troubles that you didn't expect Instead of depending on something that does a million things, depend on a interface you write that does exactly what you need - and then \"plug-in\" the thing that does a million things. Then you are only coupled to the functionality that you care about.","title":"Interface Segregation Principle"},{"location":"programming/clean-architecture/#dependency-inversion-principle","text":"The most flexible systems depend on abstractions, not concretions Concrete implementation details should always depend on abstract stable code. Basically, buiseness logic should never need to change when the UI changes. Buiseness rules should never need to change when the database or ORM change. If you find yourself in a situation where the abstract is depending the concrete, you should invert the dependency by creating an interface and then the abstract code and concrete implementation both depend on the interface (which is abstract).","title":"Dependency Inversion Principle"},{"location":"programming/clean-architecture/#component-principles","text":"Gather together logic that changes together, dont depend on things you don't need, and version control your components. Components exist in a tension between three principals: CRP(avoid unneeded releases) | | |Too many changes |Hard to reuse | | | Your component | | | | | | | REP(reusers)--------------CCP(maintenance) | Too many releases REP - Reuse/Release Equivalence Principle: A component should be releasable together CCP - Common Closure Principle: A component should change together for only one reason CRP - Common Reuse Principle: Code that is reused together should be in the same component. If you depend on part of a component, you depend on the whole thing - so only depend on stuff you use 100% of.","title":"Component Principles"},{"location":"programming/clean-architecture/#component-coupling","text":"Always draw out your components and the dependencies between them, if there is a cycle use DIP to break the cycle so that you can work on components independently and not force extra releases. Component architecture should be flexible and allowed to change constantly.","title":"Component Coupling"},{"location":"programming/clean-architecture/#stable-abstractions-principle","text":"A component should be as abstract as it is stable Components are sespended between the three principles outlined above while also being suspended between The zone of uselessness and The zone of pain . A component is in The zone of uselessness if it is abstract and nothing depends on it. (Ex: leftover dead abstract classes) A component is the The zone of pain if it is concrete and many things depend on it. (Ex: Database schema) You should aim to keep components as abstract as they are stable. So something that is depended on greatly should be greatly abstract, while something depended on by nothing can be extreamly concrete and depend on many things itself.","title":"Stable Abstractions Principle"},{"location":"programming/clean-architecture/#architecture","text":"It's all coming together... Basically a project can be split vertically and horizontally: Components (x), Use Cases (y) y (use cases EX: add order, delete order) | | | | | | | |------------- | | | |------------- | | ----------------- x (components EX: The ui, application-specific business rules, application-indebendent business rules, the database) You should be able to add use cases and components without interfearing with old ones. You should be able to pinpoint the exact code that handles a specific use case at a specific layer. This can all be in a monolith or components can be deployed as services - it does not really matter and is more domain specific. Consider the \"chattyness\" between layers. Remember that network requests are slow af, so if two layers are super chatty - having that chatter happen over the network will be slow. You should be able to test these layers horizontally (unit) and vertically (integration). Huzzah!","title":"Architecture"},{"location":"programming/clean-architecture/#screaming-architecture","text":"When you look at an apps source code it should scream what it is. Ex: \"I AM A LOAN RISK ANALYSIS FINANCE APP CURRENTLY USING NEXTJS TO BE PRESENTED ON THE WEB\". rather than: \"I AM A CREATE-NEXT-APP.\"","title":"Screaming Architecture"},{"location":"programming/clean-architecture/#clean-architecture_1","text":"Using all of the principles we have talked about, a clean architecture should be obvious by now | Abstract + Stable Entities (Enterprise Business Rules) *knows nothing about* Use Cases (Application Business Rules) *knows nothing about* Controllers + Presenters + Gateways (Interface Adapters) *knows nothing about* UI + Web + Devices + DB + External Interfaces (Frameworks & Drivers) | Concrete + Easy to change Yes, frameworks and databases and the web itself are all at the bottom. And, as a fractal, you can see this same architecture scaling up and down with each layer while maintaining the clarity of Use Cases vs Components and testing vertically/horizontally. Communication between these layers should be humble objects so that each layer is interchangable. You should be able to totally change frameworks at any time and only touch the bottom layer. Note: The start script (main) should be and interchangible plugin. You should easily be able to start in production, start in dev, start in qa, etc...","title":"Clean Architecture"},{"location":"programming/clean-code/","text":"Clean Code By: Robert C. Martin Clean code is subjective I really liked Bjarne Stroustrup's definition: I like my code to be elegant and efficient. The logic should be straightforward to make it hard for bugs to hide, the dependencies minimal to ease maintenance, error handling complete according to an articulated strategy, and performance close to optimal. Clean code does one thing well. Basically everyone seems to agree that code is clean when \"there is nothing obvious you can do to make it better\". Clean code is an artform and it is easier to label something as messy code than it is to define clean code. You should always leave files better than you found them. Names Name things as clearly as physically possible. Descriptive, distinct and pronounceable names are always the way to go - even if that means they are long. Do not make the reader translate a name into the actual concept - just name the thing the concept. Functions Functions should only do one thing and should do it well. To figure out what \"one thing\" is, write a \"TO\" paragraph: To draw a cat on screen we make a request to the server for the cats description and parse the JSON it sends back and set the description in the state of the catPresenter and.... Each of these \"AND\" statements could be refactored to another \"TO\", which means they should be an individual function. Repeat this process recursively until there are no more \"AND\"s. Error handling is one thing. Keep functions simple by keeping argument lists small. Prefer 1 argument. Comments If you have to describe the code with a comment it is a failure of your code to be descriptive enough. Only comment if you can not get around this failure, such as an issue with a dependency or a truly special case. Make sure comments stay attached to the code they are commenting on. Comments are not documentation. If you have an api, documenting the api is it's own seperate concern and is a very good thing to do. Formatting Take your work seriosly and write exceptionally well formatted code that looks sharp. Objects and Data Structures The Law of Demeter states that an object should not expose it's data but should expose methods to access the data, unless that object was created by the thing accessing the data. An exception to this rule can be DTOs (although some purist still write getters). Errors Error handling should be the first thing you care about. Write your try catch first, and use errors to describe when code leaves the happy path - don't return null or something to show something failed. In general. Libraries When learning how to use a library, write tests to verify your learning of the features you will use. This also helps you migrate up major versions. Testing Theoretically untested code is unverifiable and should not go in to production ever in any situation. Following the three laws of TDD is ideal. You may not write production code until you have written a failing unit test. You may not write more of a unit test than is sufficient to fail. Not compiling is failing. You may not write more production code than is sufficient to pass the currently failing test. Also, your test code should be as clean as your production code. Modules and Classes Should be small and do one thing. Just like functions and methods but one level of abstraction up. Emergence Clean code shows signs of emergent concepts. You should notice that you can call domain specific functions more often than implimentation functions. Your code should scream that it is about something and the level of abstraction for each individual function and class should be clear. Concurrency Concurrency is hard and is not always a good solution. If you do decide to use concurrency, make sure your code works individually first - concurrency is a seperate concern. Keep synchronization points few and short. Use an established execution model. Producer-Consumer One or more producers threads create some work and place it in a bugger or queue. One or more consumers grab the work and complete it. The queue is a bound resource . Producers and consumers have to communicate around when they can access the bound resource. Before writing concurrent code read about the readers-writers problem and dining philosophers problem.","title":"Clean Code"},{"location":"programming/clean-code/#clean-code","text":"By: Robert C. Martin","title":"Clean Code"},{"location":"programming/clean-code/#clean-code-is-subjective","text":"I really liked Bjarne Stroustrup's definition: I like my code to be elegant and efficient. The logic should be straightforward to make it hard for bugs to hide, the dependencies minimal to ease maintenance, error handling complete according to an articulated strategy, and performance close to optimal. Clean code does one thing well. Basically everyone seems to agree that code is clean when \"there is nothing obvious you can do to make it better\". Clean code is an artform and it is easier to label something as messy code than it is to define clean code. You should always leave files better than you found them.","title":"Clean code is subjective"},{"location":"programming/clean-code/#names","text":"Name things as clearly as physically possible. Descriptive, distinct and pronounceable names are always the way to go - even if that means they are long. Do not make the reader translate a name into the actual concept - just name the thing the concept.","title":"Names"},{"location":"programming/clean-code/#functions","text":"Functions should only do one thing and should do it well. To figure out what \"one thing\" is, write a \"TO\" paragraph: To draw a cat on screen we make a request to the server for the cats description and parse the JSON it sends back and set the description in the state of the catPresenter and.... Each of these \"AND\" statements could be refactored to another \"TO\", which means they should be an individual function. Repeat this process recursively until there are no more \"AND\"s. Error handling is one thing. Keep functions simple by keeping argument lists small. Prefer 1 argument.","title":"Functions"},{"location":"programming/clean-code/#comments","text":"If you have to describe the code with a comment it is a failure of your code to be descriptive enough. Only comment if you can not get around this failure, such as an issue with a dependency or a truly special case. Make sure comments stay attached to the code they are commenting on. Comments are not documentation. If you have an api, documenting the api is it's own seperate concern and is a very good thing to do.","title":"Comments"},{"location":"programming/clean-code/#formatting","text":"Take your work seriosly and write exceptionally well formatted code that looks sharp.","title":"Formatting"},{"location":"programming/clean-code/#objects-and-data-structures","text":"The Law of Demeter states that an object should not expose it's data but should expose methods to access the data, unless that object was created by the thing accessing the data. An exception to this rule can be DTOs (although some purist still write getters).","title":"Objects and Data Structures"},{"location":"programming/clean-code/#errors","text":"Error handling should be the first thing you care about. Write your try catch first, and use errors to describe when code leaves the happy path - don't return null or something to show something failed. In general.","title":"Errors"},{"location":"programming/clean-code/#libraries","text":"When learning how to use a library, write tests to verify your learning of the features you will use. This also helps you migrate up major versions.","title":"Libraries"},{"location":"programming/clean-code/#testing","text":"Theoretically untested code is unverifiable and should not go in to production ever in any situation. Following the three laws of TDD is ideal. You may not write production code until you have written a failing unit test. You may not write more of a unit test than is sufficient to fail. Not compiling is failing. You may not write more production code than is sufficient to pass the currently failing test. Also, your test code should be as clean as your production code.","title":"Testing"},{"location":"programming/clean-code/#modules-and-classes","text":"Should be small and do one thing. Just like functions and methods but one level of abstraction up.","title":"Modules and Classes"},{"location":"programming/clean-code/#emergence","text":"Clean code shows signs of emergent concepts. You should notice that you can call domain specific functions more often than implimentation functions. Your code should scream that it is about something and the level of abstraction for each individual function and class should be clear.","title":"Emergence"},{"location":"programming/clean-code/#concurrency","text":"Concurrency is hard and is not always a good solution. If you do decide to use concurrency, make sure your code works individually first - concurrency is a seperate concern. Keep synchronization points few and short. Use an established execution model. Producer-Consumer One or more producers threads create some work and place it in a bugger or queue. One or more consumers grab the work and complete it. The queue is a bound resource . Producers and consumers have to communicate around when they can access the bound resource. Before writing concurrent code read about the readers-writers problem and dining philosophers problem.","title":"Concurrency"},{"location":"programming/continuous-delivery/","text":"Continuous Delivery You cannot prove something is true in science, but you can prove something is true enough for your purposes. The way you do this is by trying as hard as you can to prove a commit should not go out to production. This should be automated. Commit test (technical), acceptance tests (does this provide value to the user).","title":"Continuous Delivery"},{"location":"programming/continuous-delivery/#continuous-delivery","text":"You cannot prove something is true in science, but you can prove something is true enough for your purposes. The way you do this is by trying as hard as you can to prove a commit should not go out to production. This should be automated. Commit test (technical), acceptance tests (does this provide value to the user).","title":"Continuous Delivery"},{"location":"programming/javascript/","text":"Javascript Javascript is a browser implementation of the ecmascript language specification Node is v8 server side. Node is single threaded Variables ```js let b = \"World\"; // a mutable variable const c = \"!\"; // a constant var a = \"Hello\"; // older \"let\", should generally be avoided // functions are first class function myFunction() {} const myFunction = (...args) => {} ``` ## Functions Functions are objects and can have properties and methods. Functions are first class. ## Promises A Promise is an object representing the eventual completion or failure of an asynchronous operation. States: - Pending - Resolved - Rejected Once resolved or rejected it can never go back to pending Callback functions are run after asynchronous code finishes\u2026aka promises resolve ## Context this in a function is the object the represents the functions context. js /** call * a method placed on a function that calls the function * the first argument passed in is the new execution context (thisArg) */ const addToThis = (anyNumber) => { return this.num + anyNumber; }; let obj = {num: 3}; addToThis.call(obj, 7); //=> 10 ## OOP The class is the context ES2015 syntactic suger is covering up JS\u2019 actual inheritance model: Prototypal inheritance ```js class Dog extends Mammal{ constructor(...args) {} static set get //etc... } ##### Great OOP design: SOLID Liskov\u2019s substitution principle: Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. Child classes can _expand_ upon what they inherited, adding methods or extra properties, do not modify what they inherited. ## FP - Pure functions - deterministic - Minimize side effects to the end of the application (rendering and such as) - Higher order functions - functions are a data type that can be passed into things ```txt gradually building something with currying someFunction()()() => each function returns a function memoization keep data and behavior seperate","title":"Javascript"},{"location":"programming/javascript/#javascript","text":"Javascript is a browser implementation of the ecmascript language specification Node is v8 server side. Node is single threaded","title":"Javascript"},{"location":"programming/javascript/#variables","text":"```js let b = \"World\"; // a mutable variable const c = \"!\"; // a constant var a = \"Hello\"; // older \"let\", should generally be avoided // functions are first class function myFunction() {} const myFunction = (...args) => {} ``` ## Functions Functions are objects and can have properties and methods. Functions are first class. ## Promises A Promise is an object representing the eventual completion or failure of an asynchronous operation. States: - Pending - Resolved - Rejected Once resolved or rejected it can never go back to pending Callback functions are run after asynchronous code finishes\u2026aka promises resolve ## Context this in a function is the object the represents the functions context. js /** call * a method placed on a function that calls the function * the first argument passed in is the new execution context (thisArg) */ const addToThis = (anyNumber) => { return this.num + anyNumber; }; let obj = {num: 3}; addToThis.call(obj, 7); //=> 10 ## OOP The class is the context ES2015 syntactic suger is covering up JS\u2019 actual inheritance model: Prototypal inheritance ```js class Dog extends Mammal{ constructor(...args) {} static set get //etc... } ##### Great OOP design: SOLID Liskov\u2019s substitution principle: Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. Child classes can _expand_ upon what they inherited, adding methods or extra properties, do not modify what they inherited. ## FP - Pure functions - deterministic - Minimize side effects to the end of the application (rendering and such as) - Higher order functions - functions are a data type that can be passed into things ```txt gradually building something with currying someFunction()()() => each function returns a function memoization keep data and behavior seperate","title":"Variables"},{"location":"programming/linux/","text":"Linux Handy tips: ctrl r -> bash history search chmod -> the permission changing linux command chown -> changes ownership 3 levels: a - all g - group o - owner users are in groups. use id to see what groups you are in File permissions are set by three octet bites ll {file} => permission octet r read w write x execute user|group|all -rw-rw-r\u2014 chmod 777 {file} -R(for recursive things) = -rwxrwxrwx permissions chmod a+x {file} all peeps execution and write use top to peek at system resources and activity","title":"Linux"},{"location":"programming/linux/#linux","text":"Handy tips: ctrl r -> bash history search chmod -> the permission changing linux command chown -> changes ownership 3 levels: a - all g - group o - owner users are in groups. use id to see what groups you are in File permissions are set by three octet bites ll {file} => permission octet r read w write x execute user|group|all -rw-rw-r\u2014 chmod 777 {file} -R(for recursive things) = -rwxrwxrwx permissions chmod a+x {file} all peeps execution and write use top to peek at system resources and activity","title":"Linux"},{"location":"programming/networking/","text":"Networking","title":"Networking"},{"location":"programming/networking/#networking","text":"","title":"Networking"},{"location":"programming/web-rtc/","text":"WebRTC WebRTC is an api that handles the networking complexity of connecting two device media streams peer to peer. Each peer needs to have a RTCPeerConnection instance. This API is built in to modern browsers. The ICE protocol is used to generate media traversal candidates which can be used in WebRTC applications, and which can be successfully sent and received through NATs. ICE utilizes different technologies and protocols to overcome the challenges posed by different types of NAT mappings. The two most prominent protocols are STUN and TURN. Both STUN and TURN require implementation of client and server-side components. STUN is used to figure out a path through the NAT configuration and then it goes away. TURN on the otherhand is a paid intermediate service that actually participates in the peer to peer connection. Typically both parties store their session description protocol (SDP) on an external server (your server) to keep a source of truth on the RTC session. Each peer uses their RTCPeerConnection.localDescription to generate this SDP. Connecting There are two implementations of the ICE protocol - trickle and non-trickle. Trickle ICE is when you use websockets (or similar tech) to update the SDP source of truth with up to date ICE candidates whenever there is a state change. Trickle ICE is an OPTIMIZATION on top of ICE, so you can just let all ICE candidates resolve before updating the source of truth with your offer and SDP Resources https://temasys.io/ice-and-webrtc-what-is-this-sorcery-we-explain/","title":"WebRTC"},{"location":"programming/web-rtc/#webrtc","text":"WebRTC is an api that handles the networking complexity of connecting two device media streams peer to peer. Each peer needs to have a RTCPeerConnection instance. This API is built in to modern browsers. The ICE protocol is used to generate media traversal candidates which can be used in WebRTC applications, and which can be successfully sent and received through NATs. ICE utilizes different technologies and protocols to overcome the challenges posed by different types of NAT mappings. The two most prominent protocols are STUN and TURN. Both STUN and TURN require implementation of client and server-side components. STUN is used to figure out a path through the NAT configuration and then it goes away. TURN on the otherhand is a paid intermediate service that actually participates in the peer to peer connection. Typically both parties store their session description protocol (SDP) on an external server (your server) to keep a source of truth on the RTC session. Each peer uses their RTCPeerConnection.localDescription to generate this SDP.","title":"WebRTC"},{"location":"programming/web-rtc/#connecting","text":"There are two implementations of the ICE protocol - trickle and non-trickle. Trickle ICE is when you use websockets (or similar tech) to update the SDP source of truth with up to date ICE candidates whenever there is a state change. Trickle ICE is an OPTIMIZATION on top of ICE, so you can just let all ICE candidates resolve before updating the source of truth with your offer and SDP","title":"Connecting"},{"location":"programming/web-rtc/#resources","text":"https://temasys.io/ice-and-webrtc-what-is-this-sorcery-we-explain/","title":"Resources"},{"location":"programming/computer-science/asymptotic-analysis/","text":"Asymptotic Analysis Big O A mathematical function can be Big O of another function if it is bounded above (less than) by that function after a certain point and multiplied by a constant C (AKA less than or equal to) Just have to prove that one constant (C) works T(N) is O(F(N)) if and only if C * F(N) is forevermore above T(N) after N * x (the crossing point) Close relatives are Omega (greater than or equal to) and Theta (equal to) T(N) is BigOmega(F(N)) if and only if C * F(N) is forevermore below T(N) after N * x Theta means both are true Little o means all constant C there exists some larger \"N not\" there is a upper bound C *f(n) for T(N) strictly less than Solid resource on Big O -> http://web.mit.edu/16.070/www/lecture/big_o.pdf \"Big-Oh\" means that you have reduced F(N) to the sweet spot of abstraction by performing Asymptotic Analysis. Suppress constant factors (from the environment EX: lines of code) and lower-order terms (that are irrelevant for large inputs). A merge sort example can be proved (via binary recursion tree) to have an upper bound of 6N(log2(n) + 6N) , you can suppress constant factors and lower-order terms even farther to reach a \"Big-Oh\" of Nlog(N) Guiding Principles for Analysis of Algorithms Use \"Worst Case\" analysis Make absolutely no assumptions about the input. \"Average Case\" and \"Benchmark\" analysis require domain specific knowledge but can be useful for practical applications. Do not worry (too much) about constant factors or lower-order terms Simpler and sloppy upward bounds for easier mathematics Constants depend on machines and there is no reason to track those small changes Asymptotic Analysis Focus on large input sizes (N) Only big problems are interesting A Fast Algorithm \ud83d\udd25 === worst-case running time grows slowly with input size (Good Asymptotic running time) Aim for mathematical tactility and predictive power Aspire to linear running time","title":"Asymptotic Analysis"},{"location":"programming/computer-science/asymptotic-analysis/#asymptotic-analysis","text":"","title":"Asymptotic Analysis"},{"location":"programming/computer-science/asymptotic-analysis/#big-o","text":"A mathematical function can be Big O of another function if it is bounded above (less than) by that function after a certain point and multiplied by a constant C (AKA less than or equal to) Just have to prove that one constant (C) works T(N) is O(F(N)) if and only if C * F(N) is forevermore above T(N) after N * x (the crossing point) Close relatives are Omega (greater than or equal to) and Theta (equal to) T(N) is BigOmega(F(N)) if and only if C * F(N) is forevermore below T(N) after N * x Theta means both are true Little o means all constant C there exists some larger \"N not\" there is a upper bound C *f(n) for T(N) strictly less than Solid resource on Big O -> http://web.mit.edu/16.070/www/lecture/big_o.pdf \"Big-Oh\" means that you have reduced F(N) to the sweet spot of abstraction by performing Asymptotic Analysis. Suppress constant factors (from the environment EX: lines of code) and lower-order terms (that are irrelevant for large inputs). A merge sort example can be proved (via binary recursion tree) to have an upper bound of 6N(log2(n) + 6N) , you can suppress constant factors and lower-order terms even farther to reach a \"Big-Oh\" of Nlog(N)","title":"Big O"},{"location":"programming/computer-science/asymptotic-analysis/#guiding-principles-for-analysis-of-algorithms","text":"Use \"Worst Case\" analysis Make absolutely no assumptions about the input. \"Average Case\" and \"Benchmark\" analysis require domain specific knowledge but can be useful for practical applications. Do not worry (too much) about constant factors or lower-order terms Simpler and sloppy upward bounds for easier mathematics Constants depend on machines and there is no reason to track those small changes Asymptotic Analysis Focus on large input sizes (N) Only big problems are interesting A Fast Algorithm \ud83d\udd25 === worst-case running time grows slowly with input size (Good Asymptotic running time) Aim for mathematical tactility and predictive power Aspire to linear running time","title":"Guiding Principles for Analysis of Algorithms"},{"location":"programming/infrastructure/container-orchestration/","text":"Container Orchestration","title":"Container Orchestration"},{"location":"programming/infrastructure/container-orchestration/#container-orchestration","text":"","title":"Container Orchestration"},{"location":"programming/infrastructure/serverless/","text":"Serverless","title":"Serverless"},{"location":"programming/infrastructure/serverless/#serverless","text":"","title":"Serverless"},{"location":"programming/infrastructure/single-server/","text":"Single Server Single server architecture is the OG.","title":"Single Server"},{"location":"programming/infrastructure/single-server/#single-server","text":"Single server architecture is the OG.","title":"Single Server"},{"location":"programming/infrastructure/static/","text":"Static If you are just distributing static files, you can use an object store like S3 to distribute those files via a CDN like Cloudfront.","title":"Static"},{"location":"programming/infrastructure/static/#static","text":"If you are just distributing static files, you can use an object store like S3 to distribute those files via a CDN like Cloudfront.","title":"Static"}]}